---
title: 异常
date: 2021-10-15
tags: [java]
---

### 概念

异常指的是程序在执行过程中，出现的非正常的情况，最终会导致 jvm 的非正常停止

在 java 等面向对象的编程语言中，异常本身是一个类，产生异常对象并抛出了一个异常对象，java 处理异常的方式是中断处理

> 异常指的并不是语法错误，语法错了，编译不通过，不会产生字节码文件，根本不能运行

### 异常体系

异常机制其实是帮助我们找到程序中的问题，异常的根类是`java.lang.Throwable`，其下有两个子类：`java.lang.Error`和`java.lang.Exception`，平时所说的异常指`java.lang.Exception`

- **Error**：严重错误，必须修改源代码，程序才能继续执行
- **Exception**：表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行

#### Throwable 中的常用方法：

- `public void printStackTrace()`：打印异常的详细信息

  包含了异常的类型，异常的原因，还包括异常出现的位置，在开发和调试阶段，都得使用`printStackTrace()`

- `public String getMessage()`：获取发生异常的原因

  提示给用户的时候，就提示错误原因

- `public String toString()`：获取异常的类型和异常描述信息

### 异常分类

- 编译时期异常（checked 异常）在编译时期，就会检查，如果没有处理异常，则编译失败
- 运行时期异常（runtime 异常）在运行时期，检查异常。在编译时期，`RuntimeException`编译器不会检测

### 异常的处理

五个关键字：throw，throws，try，catch，finally

#### 抛出异常 throw（必须写在方法的内部）

在编写程序时，我们必须要考虑程序出现问题的情况，比如，在定义方法时，方法需要接收参数。那么，当调用方法使用接收到的参数时，首先需要对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来，这时就需要使用抛出异常的方式来告诉调用者。

##### 使用格式

```java
throw new 异常类名(参数);
/*
	1.创建一个异常对象，封装一些提示信息
	2.使用throw关键字将异常对象抛出给方法的调用者，并结束当前方法的执行
*/
```

> 如果产生了异常，我们将异常对象 throw 给方法的调用者，对于调用者来说，一种是进行捕获处理，另一种就是继续将对象使用 throws 声明抛出出去

#### 声明异常 throws（必须写在方法声明处）

声明异常：将问题标识出来，报告给调用者，如果方法内通过 throw 抛出了编译期异常，而没有进行捕获处理，那么必须通过 throws 进行声明，让调用者处理

##### 使用格式

```java
修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2...{

}
```

#### 捕获异常 try...catch

try...catch 的方式就是捕获异常

##### 使用格式

```java
try{
    // 可能出现异常的代码
}catch(异常类型 e){
    // 记录日志、打印异常信息，继续抛出异常
}
```

#### finally 代码块

有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到，放在`finally`代码块中的代码都是一定会被执行的

例如：

​ 当我们在 try 语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。

> finally 不能单独使用

### 注意事项

- 多个异常使用捕获该如何处理

  1. 多个异常分别处理
  2. 多个异常一次捕获，多次处理
  3. 多个异常一次捕获，一次处理

  一般采用一次捕获多次处理的方式

  ```java
  try{
      可能产生异常的代码
  }catch(异常类型A e){
      // ...
  }catch(异常类型B e){
      // ...
  }
  ```

  > 这种异常处理方式，要求多个 catch 中的异常不能相同，并且若 catch 中的多个异常之间有子父类关系，那么子类异常要求在上面的 catch 处理，父类异常在下面的 catch 处理

- 运行时异常被抛出可以不处理，即不捕获也不声明抛出，默认交给 JVM 处理(打印异常对象,中断程序)
- 如果 finally 有 return 语句，会永远返回 finally 中的结果，避免这种情况
- 如果父类抛出了多个异常，子类重写父类方法时，抛出和父类相同的异常，或者父类异常的子类，或者不抛出异常
- 父类没有抛出异常，子类重写父类该方法时，也不可抛出异常。此时子类产生的异常只能捕获处理，不能声明抛出

### 自定义异常类

1.  自定义一个编译期异常: 自定义类并继承于`java.lang.Exception`。
2.  自定义一个运行时期的异常类:自定义类并继承于`java.lang.RuntimeException`。
